{"version":3,"sources":["../src/index.ts","../src/validatePackageExports.ts"],"names":[],"mappings":"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","sourcesContent":["import core from '@actions/core';\nimport github from '@actions/github';\nimport { readFileSync } from 'node:fs';\nimport { validatePackageExports } from './validatePackageExports.js';\n\nconst findLineNumber = (packageJsonContent: string, path: string[]): number => {\n\tlet currentObj = JSON.parse(packageJsonContent);\n\tlet parsedKey = path[0];\n\n\tfor (const key of path) {\n\t\tparsedKey = key;\n\t\tif (parsedKey.startsWith('\"') && parsedKey.endsWith('\"')) {\n\t\t\tparsedKey = parsedKey.slice(1, -1);\n\t\t}\n\n\t\tif (\n\t\t\t!currentObj ||\n\t\t\ttypeof currentObj !== 'object' ||\n\t\t\t!(parsedKey in currentObj)\n\t\t) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tcurrentObj = currentObj[parsedKey];\n\t}\n\n\tif (parsedKey === undefined) {\n\t\tthrow new Error('No key found');\n\t}\n\n\tconst packageJsonLines = packageJsonContent.split('\\n');\n\treturn packageJsonLines.findIndex((line) => line.includes(currentObj)) + 1;\n};\n\ntry {\n\tconst inputFiles = core.getInput('inputFiles', {\n\t\trequired: true,\n\t\ttrimWhitespace: true,\n\t});\n\t/* core.info(fullGreeting); */\n\tcore.setOutput('fullGreeting', 'hi');\n\n\t// Get the JSON webhook payload for the event that triggered the workflow\n\t// const payload = JSON.stringify(github.context.payload, undefined, 2);\n\tconst octo = github.getOctokit(core.getInput('token', { required: true }));\n\n\tconst res = await validatePackageExports(inputFiles);\n\n\tif (res === null) {\n\t\tocto.rest.checks.create({\n\t\t\towner: github.context.repo.owner,\n\t\t\trepo: github.context.repo.repo,\n\t\t\tname: 'My Check',\n\t\t\thead_sha: github.context.sha,\n\t\t\tstatus: 'completed',\n\t\t\tconclusion: 'success',\n\t\t});\n\n\t\tprocess.exit(0);\n\t}\n\n\tconst packageJsonContents = new Map<string, string>();\n\tconst errors = [];\n\tfor (const error of res) {\n\t\tconst {\n\t\t\tentryPoint: { packagePath, itemPath, subpath },\n\t\t\tmessage,\n\t\t\tname,\n\t\t} = error;\n\n\t\tif (!packageJsonContents.has(packagePath)) {\n\t\t\tpackageJsonContents.set(packagePath, readFileSync(packagePath, 'utf8'));\n\t\t}\n\n\t\tconst lineNumber = findLineNumber(\n\t\t\t// biome-ignore lint/style/noNonNullAssertion: we know the packagePath is in the map because we just set it\n\t\t\tpackageJsonContents.get(packagePath)!,\n\t\t\titemPath\n\t\t);\n\n\t\terrors.push({\n\t\t\tpath: packagePath,\n\t\t\tstart_line: lineNumber,\n\t\t\tend_line: lineNumber,\n\t\t\tannotation_level: 'failure',\n\t\t\tmessage: `${name}: ${message} in ${subpath}`,\n\t\t});\n\t}\n\n\tocto.rest.checks.create({\n\t\towner: github.context.repo.owner,\n\t\trepo: github.context.repo.repo,\n\t\tname: 'My Check',\n\t\thead_sha: github.context.sha,\n\t\tstatus: 'completed',\n\t\tconclusion: 'failure',\n\t\toutput: {\n\t\t\ttitle: 'Error',\n\t\t\tsummary: 'An error occurred',\n\t\t\t// @ts-expect-error\n\t\t\tannotations: errors,\n\t\t},\n\t});\n} catch (error) {\n\tif (error instanceof Error) {\n\t\tcore.setFailed(error.message);\n\t}\n\tcore.setFailed('Unknown error');\n}\n","import { execa, type ExecaError } from 'execa';\n\nfunction assertExecaError(error: unknown): asserts error is ExecaError {\n\tif (\n\t\t!(error instanceof Error) ||\n\t\t!('stdout' in error && 'stderr' in error && 'exitCode' in error)\n\t) {\n\t\tthrow error;\n\t}\n}\n\ntype PackageExportsError = {\n\tcode: number;\n\tentryPoint: {\n\t\tcondition: string;\n\t\titemPath: string[];\n\t\tpackagePath: string;\n\t\tsubpath: string;\n\t};\n\tmessage: string;\n\tname: string;\n};\n\nexport async function validatePackageExports(\n\tinput: string\n): Promise<PackageExportsError[] | null> {\n\ttry {\n\t\tawait execa('npx', [\n\t\t\t'validate-package-exports',\n\t\t\t'--check',\n\t\t\t'--verify',\n\t\t\t'--json',\n\t\t\tinput,\n\t\t]);\n\n\t\treturn null;\n\t} catch (error) {\n\t\tassertExecaError(error);\n\t\treturn JSON.parse(error.stdout);\n\t}\n}\n"]}